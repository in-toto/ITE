= ITE-10: Layouts for in-toto Attestations
:source-highlighter: pygments
:toc: preamble
:toclevels: 2
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

.Metadata
[cols="2"]
|===
| ITE
| 10

| Title
| Layouts for in-toto Attestations

| Sponsor
| link:https://github.com/adityasaky[Aditya Sirish A Yelgundhalli]

| Status
| Draft

| Type
| Standards

| Created
| 2023-01-07

|===

[[abstract]]
== Abstract

A previous in-toto Enhancement, ITE-6, presented the in-toto Attestation
Framework. This framework introduced the idea of context-specific attestations
with their own definitions. This ITE builds on ITE-6 and proposes several
modifications to in-toto layouts that allow for defining and verifying policies
over ITE-6 attestations.

[[specification]]
== Specification

The in-toto specification describes the following schema for layouts.

```json
{
    "_type": "layout",
    "expires": "<EXPIRES>",
    "readme": "<README>",
    "keys": {
        "<KEYID>": "<PUBKEY_OBJECT>"
    },
    "steps": ["<STEP>", "..."],
    "inspect": ["<INSPECTION>", "..."]
}
```

An in-toto layout provides two semantics for software supply chain owners to
define policies: steps and inspections. Steps are used to reason about and
express constraints regarding operations _already_ performed as part of the
supply chain. The verification is focused on ensuring authorized functionaries
performed each step and validating the integrity of artifacts as they move from
one step to the next. Inspections are executed _during_ verification to perform
any other checks that are defined as external scripts.

TODO: this pass does not revise artifact rules for steps.

This ITE primarily updates the schema and capabilities for inspections. As it
stands, the inspections semantic can already be used to apply arbitrary
constraints to data captured in in-toto links. Similarly, they can apply
constraints to attestations as well. We update in-toto inspections with more
capabilities so that they do not necessarily have to be executed as separate
scripts. This is achieved by providing multiple options for the domain specific
language used to express constraints. Currently, inspections only support using
in-toto's artifact rules. With this ITE, this will remain an option, but
inspections can also be written to not execute separate shell scripts and use
artifact rules, and instead express data constraints using DSLs like Rego or
Cue. The current inspection schema is as follows:

```json
{
    "_type": "inspection",
    "name": "<NAME>",
    "expected_materials": [
        [ "<ARTIFACT_RULE>" ],
        "..."
    ],
    "expected_products": [
        [ "<ARTIFACT_RULE>" ],
        "..."
    ],
    "run": "<COMMAND>"
}
```

The above schema can also be expressed using the following generalization that
allows for multiple DSLs. Note that several fields are optional.


```json
{
    "_type": "inspection",
    "name": "<NAME>",
    "functionaries": ["<KEYID>", "..."],
    "threshold": "<THRESHOLD>",
    "subject": ["<SUBJECT>", "..."],
    "policyLanguage": "<POLICY_LANGUAGE>",
    "policy": "<POLICY>",
    "run": "<COMMAND>"
}
```

Currently supported inspections _always_ execute a command or script and
generate link metadata. As this is during verification, they are not signed. As
such, to support the current model, `functionaries` and `threshold` are
optional. Similarly, `subject` is also unnecessary. `policyLanguage` is used to
indicate the policy is expressed as in-toto artifact rules and `policy` contains
the actual rules currently expressed as `expected_materials` and
`expected_products`.

However, this model provides a lot of flexibility when it comes to other DSLs.
Consider the following subset of the block above:

```json
{
    "_type": "inspection",
    "name": "<NAME>",
    "functionaries": ["<KEYID>", "..."],
    "threshold": "<THRESHOLD>",
    "subject": ["<SUBJECT>", "..."],
    "policyLanguage": "<POLICY_LANGUAGE>",
    "policy": "<POLICY>",
}
```

Only `run` is removed as in this example, an external command or script is not
invoked. Instead, the `policyLanguage` used is a logic programming language and
the `policy` expresses directly the checks that previously needed to be a
separate script. Here, `subject` is used to identify the sets of attestations
the policy is applied against. Further, the `functionaries` and `threshold`
fields can be used to directly check the source of the claims being verified by
the policy. In the current model, as inspections reason about link metadata
generated for the execution of the inspection itself, any inspection that
used a script to check contents of link metadata from some prior step also
needed to verify the functionary signing the metadata in the script--in-toto's
semantics are not used directly.

TODO: the last bit of the paragraph is very convoluted. What I'm trying to say
is that inspection scripts must also reason about and verify any prior metadata
they're looking at is signed by the right keys, with the right threshold, and so
on. They cannot just verify the claims themselves. This is important because:
1. you may have link metadata that was signed by the wrong functionary, rejected
   during verification of the step, but the threshold was still met. Claims made
   by this metadata shouldn't be trusted by inspections.
2. you may have link metadata with differing attributes for the same step by
   design. One example: reproducible builds with one piece of metadata generated
   by an isolated environment. The inspection here should be able to reason
   about which metadata has these claims and if it's from the right environment.

Note that a policy specified in an inspection block is not applied to some
specified set of attestation types. Policies apply to _subjects_ of the supply
chain, whether artifacts or other processes captured using ITE-4 semantics.
During the verification workflow, all attestations are parsed to represent their
claims in the context of the subjects they apply to. So, all available
information for a subject is available along with the functionaries signing for
each individual claim, and this representation of attestation claims is used to
apply policies. Attestations must not be parsed if their signatures cannot be
verified using functionary information available in the layout.

=== Specifying Policies

In general, each unit policy applies one constraint. For example, a policy might
mirror in-toto's artifact rules, ensuring that all the materials and products of
some step in the supply chain are as expected. Alternatively, a policy can apply
a property-oriented constraint to an artifact or step, such as validating the
Provenance of an artifact or that its build process was performed in an isolated
and hermetic build environment. Note that all of these types of policies can
coexist and successful verification is contingent on all policy validations
succeeding.

This indicates that developers need a great deal of flexibility in specifying
policies _and_ that any domain-specific language chosen or created to express
policies must have the necessary capabilities to fit these requirements.

Prior literature has explored the use of logic based languages and their
derivatives for specifying and validating policies. Policies, at their core, are
logic programs that are applied against a set of claims, expressed here as
in-toto attestations. This ITE uses languages such as Rego and CUE as examples
of such languages, but leaves the specific choices to the in-toto community and
adopters. The new layout schema proposed above includes a `<POLICY_LANGUAGE>`
attribute for each policy to enable this variety in choice.

=== Validating Policies

The in-toto verification workflow is updated to support different types of
inspections as defined in this ITE. For new style inspection blocks, the
verification workflow uses the `policyLanguage` field to decide which policy
engine to use. If `run` is specified, the workflow executes the command or
script as it does now.

[[motivation]]
== Motivation

The original in-toto specification defined only one type of metadata that was to
be captured during supply chain operations. As such, it had a uniform
verification workflow and provided supply chain owners the semantics, i.e.
artifact rules, to verify the flow of artifacts in their supply chains. ITE-6
expanded the metadata formats to support the generation of custom attestations
that have context-specific schemas. Current in-toto layouts as defined in the
in-toto specification cannot be used to verify the information contained in
these attestations without executing external scripts or commands, and cannot
directly reason about the sources of claims made in them.

[[reasoning]]
== Reasoning

The intent of ITE-6 and the in-toto Attestation framework is to enable software
producers to emit a wide range of contextual information pertaining to their
supply chain. The intent of this ITE is to extend ITE-6 with policy definitions
such that attestation producers can validate the information in ITE-6
attestations. It is clear from ITE-6 that there is not a one-size-fits-all
solution to policy definitions. Therefore, to support a wide variety of use
cases, this ITE proposes the use of existing policy languages such as Rego and
CUE.

=== Rego

Rego is a declarative policy language that is part of Open Policy Agent (OPA).
Rego policies are composed of assertion queries that are applied against some
specified data. If the data does not meet every assertion specified for it, the
policy fails.

Within the context of in-toto attestations, Rego can be used to define a set of
rules for the data contained within predicates. If every assertion passes for
some presented attestation, the in-toto verification workflow considers the
property corresponding to the policy as met.

The use of Rego over in-toto attestations is not new. Witness, an in-toto
implementation by TestifySec supports the use of Rego policies.

=== CUE

CUE is a data validation language that can be used to validate data and schemas.
It can be used to define constraints for some input data, and validation fails
if the input data does not meet the specified constraints. As with Rego, CUE can
be used to define rules for the data contained within in-toto predicates. During
verification, if some attestation is presented that does not meet all the
specified constraints, verification is unsuccessful. On the other hand, if all
the constraints specified for a property's policy are met by the attestation,
verification of that property is successful.

[[backwards-compatibility]]
== Backwards Compatibility

All the capabilities currently enabled by in-toto inspections are retained in
the changes proposed here. As such, there is no regression in capabilities.

However, any new-style inspections as defined here cannot be verified by older
in-toto implementations. Further, implementations must decide independently
their timeline of support for the old-style inspection definitions.

[[security]]
== Security


[[infrastructure-requirements]]
== Infrastructure Requirements


[[prototype-implementation]]
== Prototype Implementation

None yet.

[[testing]]
== Testing


[[references]]
== References

* link:https://www.openpolicyagent.org/docs/latest/policy-language/[Rego: Open Policy Agent's Policy Language]
* link:https://cuelang.org/docs/about/[CUE]