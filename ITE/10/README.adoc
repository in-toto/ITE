= ITE-10: Layouts for in-toto Attestations
:source-highlighter: pygments
:toc: preamble
:toclevels: 2
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

.Metadata
[cols="2"]
|===
| ITE
| 10

| Title
| Layouts for in-toto Attestations

| Sponsor
| link:https://github.com/adityasaky[Aditya Sirish A Yelgundhalli]

| Status
| Draft

| Type
| Standards

| Created
| 2023-01-07

|===

[[abstract]]
== Abstract

A previous in-toto Enhancement, ITE-6, presented the in-toto Attestation
Framework. This framework introduced the idea of context-specific attestations
with their own definitions. This ITE builds on ITE-6 and proposes several
modifications to in-toto layouts that allow for defining and verifying policies
over ITE-6 attestations.

[[specification]]
== Specification

Note: this document assumes the reader is familiar with ITE-6 and the in-toto
Attestation Framework.

in-toto layouts have two key mechanisms for specifying policies: steps and
inspections. Steps are used to reason about and express constraints regarding
operations performed as part of the supply chain. Constraints are currently
expressed using in-toto artifact rules against the materials and products of a
step. Each step definition also declares the set of functionaries authorized to
perform the step and the required number of functionaries that need to sign off
on the step.

Inspections, on the other hand, are executed during the verification workflow to
complement in-toto's step verifications with extra checks. Typically,
inspections invoke external commands or scripts shipped with the layout. They
may also use artifact rules. Currently, inspections are used for constraints
in-toto layouts do not support. For example, in-toto links can record arbitrary
information in their opaque environment and byproducts fields. To validate their
contents, supply chain owners must rely on custom verification scripts invoked
as inspections.

In this ITE, the layout is updated to support a third type of policy
specification, against attestation subjects. The updated layout schema can be
found link:layout.proto[here].

=== Classifying Predicates

Prior to ITE-6, all steps were validated against in-toto links. Inspection
executions also resulted in the generation of in-toto links that were then
validated. With the introduction of the in-toto Attestation Framework, it is
necessary to rework the layout to support verifying a variety of _predicates_.
As the framework is designed to generate claims pertaining to how software is
produced, each predicate type can be mapped to a step in the software supply
chain. However, it is first necessary to understand the nature of each step, and
therefore its predicate types. in-toto was originally designed with the
assumption that a step in the software supply chain affects in some manner the
artifacts that constitute the supply chain. ITE-6 showed that some steps do not
fit the materials and products model. This is a factor in _verifying_ such
predicates using in-toto layouts.

Therefore, all predicates supported for verification in an in-toto layout must
categorized as one of two classes:

* the link class: these are based on classic in-toto links for steps that
  transform artifacts in some manner. They consume some artifacts as materials
  and produce others as products. The subject of such attestations indicate the
  products of the step. Eg. in-toto links, SLSA Provenance.
* the attribute class: these predicates record contextual attributes about one
  or more artifacts. The operations they represent consume artifacts as
  materials (recorded as the subject of such attestations) and produce
  attributes about them as the outcome. Eg. test results, reviews.

Note that predicates that fit the first category may also record certain
attributes. For example, the environment field in in-toto links can include such
attribute information.

With this representation of different predicate types, step declarations in
layouts can _chain_ different operations represented by distinct predicate types
together, a fundamental feature of in-toto. For example, a code review step
represented by a review predicate type that follows a checkout step that fetches
source code represented by an in-toto link can use in-toto's artifact rules to
ensure the review was performed against the sources fetched by the checkout
step.

=== Step Constraints

As noted before, current in-toto layouts constraints are expressed via artifact
rules. As the previous in-toto verification model primarily focused on steps
that affected artifacts, constraints on custom attributes recorded in opaque
fields such as environment and byproducts were left to inspections. With the
rise of attribute focused predicates, in-toto layouts must support setting
constraints on their contents. Further, while in-toto layouts always supported
verifying multiple attestations for a step via the threshold functionality, they
must now support verifying attestations of different predicate types generated
during the execution of a single step.

As such, this ITE proposes the following schema for step declarations.

```yaml
name: string
command: string
expectedPredicates: list of ExpectedStepPredicates
```

Each `ExpectedStepPredicate` object has the following schema.

```yaml
predicateTypes: list of TypeURIs
expectedMaterials: list of constraints
expectedProducts: list of constraints
expectedAttributes: list of constraints
functionaries: list of strings
threshold: int
```

Each entry in `expectedMaterials`, `expectedProducts`, and `expectedAttributes`
corresponds to one rule, similar to the current in-toto layouts. However, along
with in-toto artifact rules, other DSLs may be used to specify attribute
specific constraints. Languages such as Rego, CUE, and CEL have been designed to
enable such schema and data validation. Each constraint must identify the DSL
used to ensure the verification engine can appropriately handle the rules. In
some cases, the actual rules may need to be encoded in some form prior to
embedding in the layout. The verification engine uses the information about the
language to identify how to parse the rule.

```yaml
language: string
rule: object
```

=== Subject Constraints

An alternative approach to applying policies for a software supply chain is
against the artifacts of the supply chain. Every in-toto attestation is created
against one or more artifacts recorded as that attestation's `subject`. So, a
new top-level (alongside steps) capability is proposed to verify claims that
apply to attestation subjects.

```yaml
subject: string
expectedPredicates: list of ExpectedSubectPredicates
```

The `subject` can be a pattern that is applied against all attestations in the
bundle. Every attestation that contains a subject matching the pattern is parsed
to extract the claims made. `ExpectedSubjectPredicate` is a condensed version of
`ExpectedStepPredicate`.

```yaml
predicateTypes: list of TypeURIs
expectedAttributes: list of constraints
functionaries: list of strings
threshold: int
```

The set of attestations collected for the subject may include those of a
predicate type not explicitly required in the `expectedPredicates`
field--they're silently ignored. Attribute policies specified for each expected
predicate is applied to the corresponding attestation. The verification workflow
fails if a required attestation (that matches predicate type and threshold of
signers) is unavailable or if a constraint fails.

=== Inspections

Inspections are primarily used at verification time to examine the final
products and their in-toto metadata. Inspections largely function like they do
in the current in-toto specification. They are used as a mechanism to execute
custom checks during the verification workflow. Their `expectedMaterials` and
`expectedProducts` fields are similarly enhanced with support for policy
languages alongside in-toto artifact rules, and they're joined by
`expectedAttributes` like step definitions. By default, inspections are expected
to generate in-toto links. However, the inspection declaration may specify an
alternative predicate the check may result in.

```yaml
name: string
command: string
predicates: list of TypeURIs
expectedMaterials: list of constraints
expectedProducts: list of constraints
expectedAttributes: list of constraints
```

=== Verification Workflow

As with the current in-toto specification, the verification workflow is
presented with a root layout, public keys to verify the layout's signatures, and
a bundle of in-toto attestations. As the verifier expects a certain set of
predicate types, it is also expected to be aware of the class of each predicate.
The workflow, at a high level, can be described as follows:

.   The layout's signatures are verified using the provided keys.
.   The layout is parsed and its validity, i.e. the expiration date, is
    checked.
.   The layout's contents are validated: at least one of `steps`, `subjects`,
    and `inspections` must be specified.
.   For each step in the layout, the corresponding attestations are loaded. The
    attestations must match the expected predicate types. As each attestation
    is loaded, its signatures are first verified against expected signers for
    the step. Also, a threshold of attestations are loaded where specified.
..  If the step specifies a sublayout, the verification workflow is recursively
    applied against the corresponding layout.
..  Else, after the attestations are loaded with corresponding mapping for
    materials (and products if it's a link class attestation), the constraints
    specified in `expectedMaterials`, `expectedProducts`, and
    `expectedAttributes` are verified respectively.
.   For each subject in the layout, the pattern is applied against the
    attestations bundle. The attestations that match the patterns are parsed to
    extract their claims. Each claim is associated with the subject it applies
    to, the predicate type of the claiming attestation, and the functionary that
    signed the attestation (a threshold of signatures is verified). Finally, the
    `expectedAttributes` constraints are applied against the collection of
    claims.
.   For each inspection in the layout, the command is executed and an
    attestation is generated. Then, the `expectedMaterials`,`expectedProducts`,
    and `expectedAttributes` are applied against the contents of the
    attestation.

This workflow may be encoded as follows.

```go
func Verify(layoutEnvelope, layoutKeys, attestations, now) {
    verifyLayoutSignatures(layoutEnvelope, layoutKeys)

    layout := layoutEnvelope.Payload
    verifyLayoutExpiry(layout, now)

    if layout.Steps == nil && layout.Subjects == nil && layout.Inspections == nil {
        panic
    }

    for _, step := range layout.Steps {
        stepAttestations := attestationsForStep(step.Name, attestations)
        for _, predicate := range step.ExpectedPredicates {
            predicateAttestations := attestationsForStepPredicate(predicate.Type, stepAttestations)
            if predicate.Type == LAYOUT {
                Verify(predicateAttestations[0], predicate.Functionaries, predicateAttestations[1:], now)
            } else {
                verifyAttestationSignatures(predicate.Functionaries, predicate.Threshold, predicateAttestations)
                for _, attestation := range predicateAttestations {
                    applyMaterialRules(predicate.ExpectedMaterials, attestation)
                    applyProductRules(predicate.ExpectedProducts, attestation)
                    applyAttributeRules(predicate.ExpectedAttributes, attestation)
                }
            }
        }
    }

    for _, subject := range layout.Subjects {
        subjectAttestations := attestationsForSubject(subject.Pattern, attestations)
        for _, predicate := range subject.ExpectedPredicates {
            predicateAttestations := attestationsForSubjectPredicate(predicate.Type, subjectAttestations) // DRY
            verifyAttestationSignatures(predicate.Functionaries, predicate.Threshold, predicateAttestations)
            for _, attestation := range predicateAttestations {
                verifyAttributeRules(predicate.ExpectedAttributes, attestation)
            }
        }
    }

    for _, inspection := range layout.Inspections {
        attestation := executeInspection(inspection.Command, inspection.PredicateType)
        applyMaterialRules(inspection.ExpectedMaterials, attestation)
        applyProductRules(inspection.ExpectedProducts, attestation)
        applyAttributeRules(inspection.ExpectedAttributes, attestation)
    }
}
```

[[motivation]]
== Motivation

The original in-toto specification defined only one type of metadata that was to
be captured during supply chain operations. As such, it had a uniform
verification workflow and provided supply chain owners the semantics, i.e.
artifact rules, to verify the flow of artifacts in their supply chains. ITE-6
expanded the metadata formats to support the generation of custom attestations
that have context-specific schemas. Current in-toto layouts as defined in the
in-toto specification cannot be used to verify the information contained in
these attestations without executing external scripts or commands, and cannot
directly reason about the sources of claims made in them.

[[reasoning]]
== Reasoning

This ITE presents certain changes that necessitate further reasoning.

=== Predicate Classification

One of in-toto's key properties is the ability to chain different steps
together, and therefore verifying every step used the right artifacts. By
classifying predicates based on the type of step they represent, we gain the
ability to place attestations that exclusively contain claims about artifacts in
the steps graph.

=== New Policy Languages

The intent of ITE-6 and the in-toto Attestation framework is to enable software
producers to emit a wide range of contextual information pertaining to their
supply chain. The intent of this ITE is to extend ITE-6 with policy definitions
such that attestation producers can validate the information in ITE-6
attestations. It is clear from ITE-6 that there is not a one-size-fits-all
solution to policy definitions. Therefore, to support a wide variety of use
cases, this ITE proposes the use of existing policy languages such as Rego, CUE,
and CEL.

[[backwards-compatibility]]
== Backwards Compatibility

All the capabilities currently enabled by in-toto inspections are retained in
the changes proposed here. As such, there is no regression in capabilities.

However, any new-style inspections as defined here cannot be verified by older
in-toto implementations. Further, implementations must decide independently
their timeline of support for the old-style inspection definitions.

[[security]]
== Security

This ITE does not significantly affect the security of in-toto layouts. It
preserves all of the existing capabilities of layouts. That said, as the ITE
allows for using externally created languages to write constraints executed at
verification time, implementers of the ITE are urged to choose the languages
they support carefully. Each language must be evaluated on a case-by-case basis
to ensure it does not introduce undesirable capabilities such as the ability to
execute arbitrary code into verification environments. Indeed, by allowing for
such limited capability languages, the hope is to reduce in-toto's dependence
on inspection scripts that have no such limitations.

[[infrastructure-requirements]]
== Infrastructure Requirements

None.

[[prototype-implementation]]
== Prototype Implementation

None yet.

[[testing]]
== Testing

Implementations of this layout schema and the accompanying verification
workflow must be thoroughly tested to ensure their backwards compatibility with
old layouts.

[[references]]
== References

* link:https://www.openpolicyagent.org/docs/latest/policy-language/[Rego: Open Policy Agent's Policy Language]
* link:https://cuelang.org/docs/about/[CUE]
* link:https://github.com/google/cel-spec[CEL]
