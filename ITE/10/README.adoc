= ITE-10: Layouts for in-toto Attestations
:source-highlighter: pygments
:toc: preamble
:toclevels: 2
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

.Metadata
[cols="2"]
|===
| ITE
| 10

| Title
| Layouts for in-toto Attestations

| Sponsor
| link:https://github.com/adityasaky[Aditya Sirish A Yelgundhalli]

| Status
| Draft

| Type
| Standards

| Created
| 2023-01-07

|===

[[abstract]]
== Abstract

A previous in-toto Enhancement, ITE-6, presented the in-toto Attestation
Framework. This framework introduced the idea of context-specific attestations
with their own definitions. This ITE builds on ITE-6 and proposes several
modifications to in-toto layouts that allow for defining and verifying policies
over ITE-6 attestations.

[[specification]]
== Specification

Note: this document assumes the reader is familiar with ITE-6 and the in-toto
Attestation Framework.

in-toto layouts have two key mechanisms for specifying policies: steps and
inspections. Steps are used to reason about and express constraints regarding
operations performed as part of the supply chain. Constraints are currently
expressed using in-toto artifact rules against the materials and products of a
step. Each step definition also declares the set of functionaries authorized to
perform the step and the required number of functionaries that need to sign off
on the step.

Inspections, on the other hand, are executed during the verification workflow to
complement in-toto's step verifications with extra checks. Typically,
inspections invoke external commands or scripts shipped with the layout. They
may also use artifact rules. Currently, inspections are used for constraints
in-toto layouts do not support. For example, in-toto links can record arbitrary
information in their opaque environment and byproducts fields. To validate their
contents, supply chain owners must rely on custom verification scripts invoked
as inspections.

=== Classifying Predicates

Prior to ITE-6, all steps were validated against in-toto links. Inspection
executions also resulted in the generation of in-toto links that were then
validated. With the introduction of the in-toto Attestation Framework, it is
necessary to rework the layout to support verifying a variety of _predicates_.
As the framework is designed to generate claims pertaining to how software is
produced, each predicate type can be mapped to a step in the software supply
chain. However, it is first necessary to understand the nature of each step, and
therefore its predicate type. in-toto was originally designed with the
assumption that a step in the software supply chain affects in some manner the
artifacts that constitute the supply chain. ITE-6 showed that some steps do not
fit the materials and products model. This is a factor in _verifying_ such
predicates using in-toto layouts.

Therefore, all predicates supported for verification in an in-toto layout must
categorized as one of two types:

* the link type: these are based on classic in-toto links for steps that affect
  artifacts in some manner. They consume some artifacts as materials and produce
  others as products. The subject of such attestations indicate the products of
  the step. Eg. in-toto links, SLSA Provenance.
* the attribute type: these predicates record contextual attributes about one or
  more artifacts. The operations they represent consume artifacts as materials
  (recorded as the subject of such attestations) and produce attributes about
  them as the outcome. Eg. test results, reviews.

Note that predicates that fit the first category may also record certain
attributes. For example, the environment field in in-toto links can include such
attribute information.

With this representation of different predicate types, step declarations in
layouts can _chain_ different operations represented by distinct predicate types
together, a fundamental feature of in-toto. For example, a code review step
represented by a review predicate type that follows a checkout step that fetches
source code represented by an in-toto link can use in-toto's artifact rules to
ensure the review was performed against the sources fetched by the checkout
step.

=== Constraints

As noted before, current in-toto layouts constraints are expressed via artifact
rules. As the previous in-toto verification model primarily focused on steps
that affected artifacts, constraints on custom attributes recorded in opaque
fields such as environment and byproducts were left to inspections. With the
rise of attribute focused predicates, in-toto layouts must support setting
constraints on their contents.

As such, this ITE proposes the following schema for step declarations.

```yaml
name: string
command: string
predicates: list of TypeURIs
expectedMaterials: list of constraints
expectedProducts: list of constraints
expectedAttributes: list of constraints
functionaries: list of strings
threshold: int
```

Each entry in `expectedMaterials`, `expectedProducts`, and `expectedAttributes`
corresponds to one rule, similar to the current in-toto layouts. However, along
with in-toto artifact rules, other DSLs may be used to specify attribute
specific constraints. Languages such as Rego, CUE, and CEL have been designed to
enable such schema and data validation. Each constraint must identify the DSL
used to ensure the verification engine can appropriately handle the rules. In
some cases, the actual rules may need to be encoded in some form prior to
embedding in the layout. The verification engine uses the information about the
language to identify how to parse the rule.

```yaml
language: string
rule: object
```

=== Verification Workflow

After verifying the layout and attestation signatures (including thresholds
where applicable), attestations must be parsed to identify the materials and
products of the step they represent. In link type predicates, the materials are
found within the predicate and products are recorded as the attestation's
subject. Note that alongside these artifacts, other predicate fields excluding
the materials must also be parsed in as part of the products to enable policies
on their contents.  For attribute type predicates, the materials are the
attestation's subject and products are exclusively the attributes recorded
within the predicate.

With this internal representation of all attestations created, each step's
material policies are applied against the material artifacts. If an error is
encountered, the verification workflow is terminated. If not, the workflow
proceeds to the product policies.

=== Role of Inspections

Inspections are primarily used at verification time to examine the final 
products and their in-toto metadata. They may be of two types. In the first,
inspections largely function like they do in the current in-toto specification.
They are used as a mechanism to execute custom checks during the verification
workflow. Their materials and products fields are similarly enhanced with
support for policy languages alongside in-toto artifact rules. By default,
inspections are expected to generate in-toto links. However, the inspection
declaration may specify an alternative predicate the check may result in.

```yaml
name: string
command: string
predicates: list of TypeURIs
expectedMaterials: list of constraints
expectedProducts: list of constraints
expectedAttributes: list of constraints
```

The second type of inspections do not execute a command or script to perform
some check. Instead, they are used to apply constraints on the _subjects_ of
in-toto attestations for a supply chain. Instead of `command`, the schema has a
`subject` field that accepts one or more patterns. The claims from all
attestations part of the verification whose subjects match the specified
patterns are collated. The inspection's constraints are then applied to the
claims pertaining to the subjects.

```yaml
name: string
subject: list of patterns
predicates: list of TypeURIs
expectedAttributes: list of constraints
```

[[motivation]]
== Motivation

The original in-toto specification defined only one type of metadata that was to
be captured during supply chain operations. As such, it had a uniform
verification workflow and provided supply chain owners the semantics, i.e.
artifact rules, to verify the flow of artifacts in their supply chains. ITE-6
expanded the metadata formats to support the generation of custom attestations
that have context-specific schemas. Current in-toto layouts as defined in the
in-toto specification cannot be used to verify the information contained in
these attestations without executing external scripts or commands, and cannot
directly reason about the sources of claims made in them.

[[reasoning]]
== Reasoning

This ITE presents certain changes that necessitate further reasoning.

=== Predicate Classification

One of in-toto's key properties is the ability to chain different steps
together, and therefore verifying every step used the right artifacts. By
classifying predicates based on the type of step they represent, we gain the
ability to place attestations that exclusively contain claims about artifacts in
the steps graph.

=== New Policy Languages

The intent of ITE-6 and the in-toto Attestation framework is to enable software
producers to emit a wide range of contextual information pertaining to their
supply chain. The intent of this ITE is to extend ITE-6 with policy definitions
such that attestation producers can validate the information in ITE-6
attestations. It is clear from ITE-6 that there is not a one-size-fits-all
solution to policy definitions. Therefore, to support a wide variety of use
cases, this ITE proposes the use of existing policy languages such as Rego, CUE,
and CEL.

[[backwards-compatibility]]
== Backwards Compatibility

All the capabilities currently enabled by in-toto inspections are retained in
the changes proposed here. As such, there is no regression in capabilities.

However, any new-style inspections as defined here cannot be verified by older
in-toto implementations. Further, implementations must decide independently
their timeline of support for the old-style inspection definitions.

[[security]]
== Security


[[infrastructure-requirements]]
== Infrastructure Requirements


[[prototype-implementation]]
== Prototype Implementation

None yet.

[[testing]]
== Testing


[[references]]
== References

* link:https://www.openpolicyagent.org/docs/latest/policy-language/[Rego: Open Policy Agent's Policy Language]
* link:https://cuelang.org/docs/about/[CUE]
* link:https://github.com/google/cel-spec[CEL]
