= ITE-10: Layouts for in-toto Attestations
:source-highlighter: pygments
:toc: preamble
:toclevels: 2
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

.Metadata
[cols="2"]
|===
| ITE
| 10

| Title
| Layouts for in-toto Attestations

| Sponsor
| link:https://github.com/adityasaky[Aditya Sirish A Yelgundhalli]

| Status
| Draft

| Type
| Standards

| Created
| 2023-01-07

|===

[[abstract]]
== Abstract

A previous in-toto Enhancement, ITE-6, presented the in-toto Attestation
Framework. This framework introduced the idea of context-specific attestations
with their own definitions. This ITE builds on ITE-6 and proposes several
modifications to in-toto layouts that allow for defining and verifying policies
over ITE-6 attestations.

[[specification]]
== Specification

Note: this document assumes the reader is familiar with ITE-6 and the in-toto
Attestation Framework.

in-toto layouts have two key mechanisms for specifying policies: steps and
inspections. Steps are used to reason about and express constraints regarding
operations performed as part of the supply chain. Constraints are currently
expressed using in-toto artifact rules against the materials and products of a
step. Each step definition also declares the set of functionaries authorized to
perform the step and the required number of functionaries that need to sign off
on the step.

Inspections, on the other hand, are executed during the verification workflow to
complement in-toto's step verifications with extra checks. Typically,
inspections invoke external commands or scripts shipped with the layout. They
may also use artifact rules. Currently, inspections are used for constraints
in-toto layouts do not support. For example, in-toto links can record arbitrary
information in their opaque environment and byproducts fields. To validate their
contents, supply chain owners must rely on custom verification scripts invoked
as inspections.

=== Classifying Predicates

Prior to ITE-6, all steps were validated against in-toto links. Inspection
executions also resulted in the generation of in-toto links that were then
validated. With the introduction of the in-toto Attestation Framework, it is
necessary to rework the layout to support verifying a variety of _predicates_.
As the framework is designed to generate claims pertaining to how software is
produced, each predicate type can be mapped to a step in the software supply
chain. However, it is first necessary to understand the nature of each step, and
therefore its predicate types. in-toto was originally designed with the
assumption that a step in the software supply chain affects in some manner the
artifacts that constitute the supply chain. ITE-6 showed that some steps do not
fit the materials and products model. This is a factor in _verifying_ such
predicates using in-toto layouts.

Therefore, all predicates supported for verification in an in-toto layout must
categorized as one of two classes:

* the link class: these are based on classic in-toto links for steps that
  transform artifacts in some manner. They consume some artifacts as materials
  and produce others as products. The subject of such attestations indicate the
  products of the step. Eg. in-toto links, SLSA Provenance.
* the attribute class: these predicates record contextual attributes about one
  or more artifacts. The operations they represent consume artifacts as
  materials (recorded as the subject of such attestations) and produce
  attributes about them as the outcome. Eg. test results, reviews.

Note that predicates that fit the first category may also record certain
attributes. For example, the environment field in in-toto links can include such
attribute information.

With this representation of different predicate types, step declarations in
layouts can _chain_ different operations represented by distinct predicate types
together, a fundamental feature of in-toto. For example, a code review step
represented by a review predicate type that follows a checkout step that fetches
source code represented by an in-toto link can use in-toto's artifact rules to
ensure the review was performed against the sources fetched by the checkout
step.

=== Constraints

As noted before, current in-toto layouts constraints are expressed via artifact
rules. As the previous in-toto verification model primarily focused on steps
that affected artifacts, constraints on custom attributes recorded in opaque
fields such as environment and byproducts were left to inspections. With the
rise of attribute focused predicates, in-toto layouts must support setting
constraints on their contents.

As such, this ITE proposes the following schema for step declarations.

```yaml
name: string
command: string
predicates: list of TypeURIs
expectedMaterials: list of constraints
expectedProducts: list of constraints
expectedAttributes: list of constraints
functionaries: list of strings
threshold: int
```

Each entry in `expectedMaterials`, `expectedProducts`, and `expectedAttributes`
corresponds to one rule, similar to the current in-toto layouts. However, along
with in-toto artifact rules, other DSLs may be used to specify attribute
specific constraints. Languages such as Rego, CUE, and CEL have been designed to
enable such schema and data validation. Each constraint must identify the DSL
used to ensure the verification engine can appropriately handle the rules. In
some cases, the actual rules may need to be encoded in some form prior to
embedding in the layout. The verification engine uses the information about the
language to identify how to parse the rule.

```yaml
language: string
rule: object
```

=== Role of Inspections

Inspections are primarily used at verification time to examine the final 
products and their in-toto metadata. They may be of two types. In the first,
inspections largely function like they do in the current in-toto specification.
They are used as a mechanism to execute custom checks during the verification
workflow. Their `expectedMaterials` and `expectedProducts` fields are similarly
enhanced with support for policy languages alongside in-toto artifact rules, and
they're joined by `expectedAttributes` like step definitions. By default,
inspections are expected to generate in-toto links. However, the inspection
declaration may specify an alternative predicate the check may result in.

```yaml
name: string
command: string
predicates: list of TypeURIs
expectedMaterials: list of constraints
expectedProducts: list of constraints
expectedAttributes: list of constraints
```

The second type of inspections do not execute a command or script to perform
some check. Instead, they are used to apply constraints on the _subjects_ of
in-toto attestations for a supply chain. Instead of `command`, the schema has a
`subject` field that accepts one or more patterns that are applied against the
subjects of all attestations in the bundle being verified. The claims from all
attestations part of the verification whose subjects match the specified
patterns are collated. The inspection's constraints are then applied to the
claims pertaining to the subjects. As these are applied against subjects rather
than steps, only `expectedAttributes` is supported.

```yaml
name: string
subject: list of patterns
predicates: list of TypeURIs
expectedAttributes: list of constraints
```

=== Verification Workflow

As with the current in-toto specification, the verification workflow is
presented with a root layout, public keys to verify the layout's signatures, and
a bundle of in-toto attestations. The workflow, at a high level, can be
described as follows:

.   The layout's signatures are verified using the provided keys.
.   The layout is parsed and its validity, i.e. the expiration date, is
    checked.
.   For each step in the layout, the corresponding attestations are loaded. The
    attestations must match the expected predicate types. As each attestation
    is loaded, its signatures are first verified against expected signers for
    the step. Also, a threshold of attestations are loaded where specified.
..  If the step specifies a sublayout, the verification workflow is recursively
    applied against the corresponding layout.
..  Else, after the attestations are loaded with corresponding mapping for
    materials (and products if it's a link class attestation), the constraints
    specified in `expectedMaterials`, `expectedProducts`, and
    `expectedAttributes` are verified respectively.
.   For each inspection:
..  If the inspection expects a command run, the command is executed and a link
    class attestation is generated. Then, the `expectedMaterials`,
    `expectedProducts`, and `expectedAttributes` are applied against the
    contents of the attestation.
..  Else, the inspection applies against one or more subjects. The patterns
    specified are against all subjects in every attestation in the bundle. The
    attestations that match the patterns are parsed to extract their claims. If
    the attestations signatures weren't verified already when verifying steps,
    the signatures are verified now. Each claim is associated with the subject
    it applies to, the predicate type of the claiming attestation, and the
    functionary that signed the attestation. Finally, the `expectedAttributes`
    constraints are applied against the collection of claims.

[[motivation]]
== Motivation

The original in-toto specification defined only one type of metadata that was to
be captured during supply chain operations. As such, it had a uniform
verification workflow and provided supply chain owners the semantics, i.e.
artifact rules, to verify the flow of artifacts in their supply chains. ITE-6
expanded the metadata formats to support the generation of custom attestations
that have context-specific schemas. Current in-toto layouts as defined in the
in-toto specification cannot be used to verify the information contained in
these attestations without executing external scripts or commands, and cannot
directly reason about the sources of claims made in them.

[[reasoning]]
== Reasoning

This ITE presents certain changes that necessitate further reasoning.

=== Predicate Classification

One of in-toto's key properties is the ability to chain different steps
together, and therefore verifying every step used the right artifacts. By
classifying predicates based on the type of step they represent, we gain the
ability to place attestations that exclusively contain claims about artifacts in
the steps graph.

=== New Policy Languages

The intent of ITE-6 and the in-toto Attestation framework is to enable software
producers to emit a wide range of contextual information pertaining to their
supply chain. The intent of this ITE is to extend ITE-6 with policy definitions
such that attestation producers can validate the information in ITE-6
attestations. It is clear from ITE-6 that there is not a one-size-fits-all
solution to policy definitions. Therefore, to support a wide variety of use
cases, this ITE proposes the use of existing policy languages such as Rego, CUE,
and CEL.

[[backwards-compatibility]]
== Backwards Compatibility

All the capabilities currently enabled by in-toto inspections are retained in
the changes proposed here. As such, there is no regression in capabilities.

However, any new-style inspections as defined here cannot be verified by older
in-toto implementations. Further, implementations must decide independently
their timeline of support for the old-style inspection definitions.

[[security]]
== Security


[[infrastructure-requirements]]
== Infrastructure Requirements


[[prototype-implementation]]
== Prototype Implementation

None yet.

[[testing]]
== Testing


[[references]]
== References

* link:https://www.openpolicyagent.org/docs/latest/policy-language/[Rego: Open Policy Agent's Policy Language]
* link:https://cuelang.org/docs/about/[CUE]
* link:https://github.com/google/cel-spec[CEL]
